<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>分析一下目前linux内核栈的实现</title>
    <url>/2020/02/27/%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%8B%E7%9B%AE%E5%89%8Dlinux%E5%86%85%E6%A0%B8%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近在看内核一个<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/sunrpc/auth_gss/gss_krb5_seqnum.c?h=v5.6-rc3&id=e7afe6c1d486b516ed586dcc10b3e7e3e85a9c2b" target="_blank" rel="noopener">patch</a>的修改，这个patch的commit描述<br>如下:</p>
<blockquote>
<p>While trying to reproduce a reported kernel panic on arm64, I discovered<br>that AUTH_GSS basically doesn’t work at all with older enctypes on arm64<br>systems with CONFIG_VMAP_STACK enabled.  It turns out there still a few<br>places using stack memory with scatterlists, causing krb5_encrypt() and<br>krb5_decrypt() to produce incorrect results (or a BUG if CONFIG_DEBUG_SG<br>is enabled).<br>描述里边提到CONFIG_VMAP_STACK内核宏和scatterlist。下面对它们分析。</p>
</blockquote>
<h2 id="CONFIG-VMAP-STACK"><a href="#CONFIG-VMAP-STACK" class="headerlink" title="CONFIG_VMAP_STACK"></a>CONFIG_VMAP_STACK</h2><h3 id="CONFIG-VMAP-STACK的功能"><a href="#CONFIG-VMAP-STACK的功能" class="headerlink" title="CONFIG_VMAP_STACK的功能"></a>CONFIG_VMAP_STACK的功能</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:&#x2F;share&#x2F;linux# find . -name Kconfig | xargs grep -rsn VMAP_STACK</span><br><span class="line">.&#x2F;arch&#x2F;Kconfig:821:config HAVE_ARCH_VMAP_STACK</span><br><span class="line">.&#x2F;arch&#x2F;Kconfig:841:config VMAP_STACK</span><br><span class="line">.&#x2F;arch&#x2F;Kconfig:844:     depends on HAVE_ARCH_VMAP_STACK</span><br><span class="line">.&#x2F;arch&#x2F;arm64&#x2F;Kconfig:135:       select HAVE_ARCH_VMAP_STACK</span><br><span class="line">.&#x2F;arch&#x2F;s390&#x2F;Kconfig:133:        select HAVE_ARCH_VMAP_STACK</span><br><span class="line">.&#x2F;arch&#x2F;s390&#x2F;Kconfig:714:        depends on !VMAP_STACK</span><br><span class="line">.&#x2F;arch&#x2F;x86&#x2F;Kconfig:152: select HAVE_ARCH_VMAP_STACK             if X86_64</span><br></pre></td></tr></table></figure>
<p>从搜索结果看，这个功能是和架构相关的。<br>再来看下该配置宏的具体描述：</p>
<blockquote>
<p>config VMAP_STACK<br>       default y<br>       bool “Use a virtually-mapped stack”<br>       depends on HAVE_ARCH_VMAP_STACK<br>       depends on !KASAN || KASAN_VMALLOC<br>       —help—<br>         Enable this if you want the use virtually-mapped kernel stacks<br>         with guard pages.  This causes kernel stack overflows to be<br>         caught immediately rather than causing difficult-to-diagnose<br>         corruption.</p>
<pre><code>To use this with KASAN, the architecture must support backing
virtual mappings with real shadow memory, and KASAN_VMALLOC must
 be enabled.</code></pre><p>如果内核开启CONFIG_VMAP_STACK，内核可以快速检测内核栈overflow异常，比之前在内核栈溢出<br>访问时出问题难以诊断，内核栈溢出肯定访问垃圾数据，其结果不可预测的，难以排查，在有个guardpage后<br>只要内核栈溢出访问，内核可以快速捕获到。</p>
</blockquote>
<p>内核栈的申请通过alloc_thread_stack_node实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static unsigned long *alloc_thread_stack_node(struct task_struct *tsk, int node)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef CONFIG_VMAP_STACK</span><br><span class="line">        void *stack;</span><br><span class="line">        int i;</span><br><span class="line"></span><br><span class="line">        for (i &#x3D; 0; i &lt; NR_CACHED_STACKS; i++) &#123;</span><br><span class="line">                struct vm_struct *s;</span><br><span class="line"></span><br><span class="line">                s &#x3D; this_cpu_xchg(cached_stacks[i], NULL);</span><br><span class="line"></span><br><span class="line">                if (!s)</span><br><span class="line">                        continue;</span><br><span class="line"></span><br><span class="line">                &#x2F;* Clear the KASAN shadow of the stack. *&#x2F;</span><br><span class="line">                kasan_unpoison_shadow(s-&gt;addr, THREAD_SIZE);</span><br><span class="line"></span><br><span class="line">                &#x2F;* Clear stale pointers from reused stack. *&#x2F;</span><br><span class="line">                memset(s-&gt;addr, 0, THREAD_SIZE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                tsk-&gt;stack_vm_area &#x3D; s;</span><br><span class="line">                tsk-&gt;stack &#x3D; s-&gt;addr;</span><br><span class="line">                return s-&gt;addr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Allocated stacks are cached and later reused by new threads,</span><br><span class="line">         * so memcg accounting is performed manually on assigning&#x2F;releasing</span><br><span class="line">         * stacks to tasks. Drop __GFP_ACCOUNT.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        stack &#x3D; __vmalloc_node_range(THREAD_SIZE, THREAD_ALIGN,</span><br><span class="line">                                     VMALLOC_START, VMALLOC_END,</span><br><span class="line">                                     THREADINFO_GFP &amp; ~__GFP_ACCOUNT,</span><br><span class="line">                                     PAGE_KERNEL,</span><br><span class="line">                                     0, node, __builtin_return_address(0));</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * We can&#39;t call find_vm_area() in interrupt context, and</span><br><span class="line">         * free_thread_stack() can be called in interrupt context,</span><br><span class="line">         * so cache the vm_struct.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (stack) &#123;</span><br><span class="line">                tsk-&gt;stack_vm_area &#x3D; find_vm_area(stack);</span><br><span class="line">                tsk-&gt;stack &#x3D; stack;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack;</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line">        struct page *page &#x3D; alloc_pages_node(node, THREADINFO_GFP,</span><br><span class="line">                                             THREAD_SIZE_ORDER);</span><br><span class="line"></span><br><span class="line">        if (likely(page)) &#123;</span><br><span class="line">                tsk-&gt;stack &#x3D; page_address(page);</span><br><span class="line">                return tsk-&gt;stack;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免vmalloc的频繁调用，内核使用cached_stacks本地缓存数组，保存进程退出时的内核栈指针。在<br>创建进程时可以直接从cached_stacks本地缓存数组获取可用的内核栈。</p>
<p>如果cached_stacks本地缓存数组不可用，则通过vmalloc接口申请内核栈。vmalloc申请的空间并不保证是<br>物理连续的页。</p>
<p>vmalloc申请的空间在使用上要注意：</p>
<ol>
<li>不能用于DMA操作<blockquote>
<p>DMA硬件没有页面映射，需要物理上连续的空间。</p>
</blockquote>
</li>
<li>不能用于scatterlist<blockquote>
<p>后面分析</p>
</blockquote>
</li>
</ol>
<p>在不启用CONFIG_VMAP_STACK时，内核使用alloc_pages_node申请内核栈空间。这个接口申请连续的物理页<br>作为内核栈。</p>
<h3 id="内核栈大小"><a href="#内核栈大小" class="headerlink" title="内核栈大小"></a>内核栈大小</h3><p>前面分析了内核栈的分配，那么内核栈占多少空间呢？</p>
<blockquote>
<p>THREAD_SIZE宏定义了内核栈的大小。</p>
</blockquote>
<p>THREAD_SIZE是架构相关的，在x86上定义为2个page的大小。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define THREAD_SIZE_ORDER       1</span><br><span class="line">#define THREAD_SIZE             (PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)</span><br></pre></td></tr></table></figure>

<p>在x86_64上定义为如下大小，开启KASAN，则分配8个page的大小，不开启KSASAN则定义为4个page的大小。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifdef CONFIG_KASAN</span><br><span class="line">#define KASAN_STACK_ORDER 1</span><br><span class="line">#else</span><br><span class="line">#define KASAN_STACK_ORDER 0</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define THREAD_SIZE_ORDER       (2 + KASAN_STACK_ORDER)</span><br><span class="line">#define THREAD_SIZE  (PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)</span><br></pre></td></tr></table></figure>

<p>这里提高了KASAN功能，这个是什么功能呢？</p>
<blockquote>
<p>Kasan 是 Kernel Address Sanitizer 的缩写，它是一个动态检测内存错误的工具，主要功能是<br>检查内存越界访问和使用已释放的内存等问题。Kasan 集成在 Linux 内核中，随 Linux 内核<br>代码一起发布，并由内核社区维护和发展。</p>
</blockquote>
<p>这里不对KASAN功能进行分析，更多的可以参考下面的文档。<br>KASAN扩展阅读</p>
<ol>
<li><a href="https://www.kernel.org/doc/html/v4.14/dev-tools/kasan.html" target="_blank" rel="noopener">KASAN内核文档</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/1608_tengr_kasan/index.html" target="_blank" rel="noopener">KASAN简单介绍</a></li>
</ol>
<h3 id="内核栈的布局"><a href="#内核栈的布局" class="headerlink" title="内核栈的布局"></a>内核栈的布局</h3><h2 id="scatterlist"><a href="#scatterlist" class="headerlink" title="scatterlist"></a>scatterlist</h2>]]></content>
      <categories>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>内核栈</tag>
        <tag>CONFIG_VMAP_STACK</tag>
        <tag>scatterlist</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/02/27/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>hexo hello</category>
      </categories>
      <tags>
        <tag>hello</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu清理磁盘空间</title>
    <url>/2020/02/25/ubuntu%E6%B8%85%E7%90%86%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>虽然linux不像windows那样需要碎片整理，随着时间的流逝，硬盘空间会<br>越来越小，有必要对硬件空间清理。以ubuntu为例说明如何清理硬盘空间。</p>
<h2 id="查看硬盘占用"><a href="#查看硬盘占用" class="headerlink" title="查看硬盘占用"></a>查看硬盘占用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            934M     0  934M   0% &#x2F;dev</span><br><span class="line">tmpfs           193M  2.6M  191M   2% &#x2F;run</span><br><span class="line">&#x2F;dev&#x2F;sda1       8.8G  6.5G  1.9G  78% &#x2F;</span><br><span class="line">tmpfs           965M     0  965M   0% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% &#x2F;run&#x2F;lock</span><br><span class="line">tmpfs           965M     0  965M   0% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">tmpfs           193M     0  193M   0% &#x2F;run&#x2F;user&#x2F;0</span><br><span class="line">tmpfs           193M     0  193M   0% &#x2F;run&#x2F;user&#x2F;1000</span><br><span class="line">&#x2F;dev&#x2F;sdb1       127G  3.0G  125G   3% &#x2F;share</span><br></pre></td></tr></table></figure>
<p>这里根分区可用空间不足，需要对根分区下目录空间占用进行分析。</p>
<h2 id="查看根分区目录空间占用"><a href="#查看根分区目录空间占用" class="headerlink" title="查看根分区目录空间占用"></a>查看根分区目录空间占用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ du -h --max-depth&#x3D;1 &#x2F;</span><br><span class="line">23M	&#x2F;opt</span><br><span class="line">0	&#x2F;dev</span><br><span class="line">236M	&#x2F;boot</span><br><span class="line">8.0K	&#x2F;snap</span><br><span class="line">5.8M	&#x2F;lib32</span><br><span class="line">3.1G	&#x2F;usr</span><br><span class="line">0	&#x2F;sys</span><br><span class="line">156M	&#x2F;root</span><br><span class="line">16K	&#x2F;lost+found</span><br><span class="line">0	&#x2F;proc</span><br><span class="line">12K	&#x2F;media</span><br><span class="line">4.0K	&#x2F;srv</span><br><span class="line">6.5M	&#x2F;libx32</span><br><span class="line">4.0K	&#x2F;lib64</span><br><span class="line">4.0K	&#x2F;mnt</span><br><span class="line">12M	&#x2F;etc</span><br><span class="line">1.1G	&#x2F;lib</span><br><span class="line">2.8G	&#x2F;share</span><br><span class="line">704M	&#x2F;var</span><br><span class="line">2.9M	&#x2F;run</span><br><span class="line">18M	&#x2F;bin</span><br><span class="line">1.1G	&#x2F;home</span><br><span class="line">19M	&#x2F;sbin</span><br><span class="line">48K	&#x2F;tmp</span><br><span class="line">4.0K	&#x2F;nextcloud</span><br><span class="line">9.2G	&#x2F;</span><br></pre></td></tr></table></figure>

<p>随着时间的流逝，log目录会比较大，可以通过journalctl命令控制日志文件所占空<br>间的大小。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ journalctl --vaccum-size&#x3D;100M</span><br></pre></td></tr></table></figure>

<h1 id="清空安装的软件包备份"><a href="#清空安装的软件包备份" class="headerlink" title="清空安装的软件包备份"></a>清空安装的软件包备份</h1><p>ubuntu把安装的软件包缓存在如下目录:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F;</span><br><span class="line">lock partial</span><br></pre></td></tr></table></figure>

<p>然后通过下面的命令删除缓存的安装包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ apt clean</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过以上步骤，硬盘空间大了许多。</p>
]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>handon</title>
    <url>/2020/01/28/handon/</url>
    <content><![CDATA[<p>hand on test</p>
]]></content>
      <tags>
        <tag>hand</tag>
      </tags>
  </entry>
  <entry>
    <title>testci</title>
    <url>/2020/01/22/testci/</url>
    <content><![CDATA[<p>test ci</p>
]]></content>
      <tags>
        <tag>ci</tag>
      </tags>
  </entry>
  <entry>
    <title>copy_file_range problem</title>
    <url>/2020/01/20/copy-file-range-problem/</url>
    <content><![CDATA[<h1 id="copy-file-range问题"><a href="#copy-file-range问题" class="headerlink" title="copy_file_range问题"></a>copy_file_range问题</h1><p>在使用3.10内核的过程中遇到一个关于copy_file_range的问题，<strong>拷贝后数据不对</strong>。有必要对这个系统调用分析一下。</p>
<h1 id="copy-file-range"><a href="#copy-file-range" class="headerlink" title="copy_file_range"></a>copy_file_range</h1><p><strong>copy_file_range</strong>是最近新增的[2]syscall，在不需要内核和用户态缓存间的拷贝就可以高效实现文件间的拷贝。传统的文件拷贝流程涉及内核page cache到用户缓存，然后由用户缓存再拷贝到内核page cache，中间涉及两次拷贝，效率不高。copy_file_range正是对拷贝的优化，内部实现是通过pipe buffer的结构，在读取源文件时把涉及到的page cache内存页，页内offset，长度信息，保存到pipe buffer中，在向目标文件拷贝时直接读取pipe buffer信息，执行后续写操作，这样仅需要一次拷贝就完成了。</p>
<p>copy_file_range的流程图如下<br><img src="/2020/01/20/copy-file-range-problem/copy_file_range_ext4.png" alt="copy_file_range flow chart"><br>可以看到最终调用pipe_to_file。下面看下该函数的实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe_to_file</span><span class="params">(struct pipe_inode_info *pipe, struct pipe_buffer *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">struct splice_desc *sd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">sd</span>-&gt;<span class="title">u</span>.<span class="title">file</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> = <span class="title">file</span>-&gt;<span class="title">f_mapping</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> offset, this_len;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *fsdata;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	offset = sd-&gt;pos &amp; ~PAGE_CACHE_MASK;</span><br><span class="line"></span><br><span class="line">	this_len = sd-&gt;len;</span><br><span class="line">	<span class="keyword">if</span> (this_len + offset &gt; PAGE_CACHE_SIZE)</span><br><span class="line">		this_len = PAGE_CACHE_SIZE - offset;</span><br><span class="line"></span><br><span class="line">	ret = pagecache_write_begin(file, mapping, sd-&gt;pos, this_len,</span><br><span class="line">	AOP_FLAG_UNINTERRUPTIBLE, &amp;page, &amp;fsdata);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(ret))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (buf-&gt;page != page) &#123;</span><br><span class="line">		<span class="keyword">char</span> *src = buf-&gt;ops-&gt;<span class="built_in">map</span>(pipe, buf, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">char</span> *dst = kmap_atomic(page);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memcpy</span>(dst + offset, src + buf-&gt;offset, this_len);</span><br><span class="line">		flush_dcache_page(page);</span><br><span class="line">		kunmap_atomic(dst);</span><br><span class="line">		buf-&gt;ops-&gt;unmap(pipe, buf, src);</span><br><span class="line">	&#125;</span><br><span class="line">	ret = pagecache_write_end(file, mapping, sd-&gt;pos, this_len, this_len,</span><br><span class="line">		page, fsdata);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面第22行判断如果不是同一page时才会执行数据拷贝操作，如果是同一page，则不执行数据操作。这样copy_file_range就不适用同一文件中拷贝。如果执行copy_file_range测试指定的是同一文件，在源偏移和目标偏移很小，即小于一个page大小时，pipe_to_file就不执行数据操作，从而导致拷贝数据不一致。</p>
<p>内核upstream上的处理流程如下图:<br><img src="/2020/01/20/copy-file-range-problem/copy_file_range_ext4_latest.png" alt="cop_file_range"></p>
<blockquote>
<p>最新版的内核已经抛弃对pipe_to_file的调用，该函数也已经从内核移除。最终的实现调用的是iov_iter_copy_from_user_atomic负责完成数据操作。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size_t iov_iter_copy_from_user_atomic(struct page *page,</span><br><span class="line">struct iov_iter *i, unsigned long offset, size_t bytes)</span><br><span class="line">&#123;</span><br><span class="line">	char *kaddr &#x3D; kmap_atomic(page), *p &#x3D; kaddr + offset;</span><br><span class="line">	if (unlikely(!page_copy_sane(page, offset, bytes))) &#123;</span><br><span class="line">		kunmap_atomic(kaddr);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	if (unlikely(iov_iter_is_pipe(i) || iov_iter_is_discard(i))) &#123;</span><br><span class="line">		kunmap_atomic(kaddr);</span><br><span class="line">		WARN_ON(1);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	iterate_all_kinds(i, bytes, v,</span><br><span class="line">		copyin((p +&#x3D; v.iov_len) - v.iov_len, v.iov_base, v.iov_len),</span><br><span class="line">		memcpy_from_page((p +&#x3D; v.bv_len) - v.bv_len, v.bv_page,v.bv_offset, v.bv_len),</span><br><span class="line">		memcpy((p +&#x3D; v.iov_len) - v.iov_len, v.iov_base, v.iov_len)</span><br><span class="line">	)</span><br><span class="line">	kunmap_atomic(kaddr);</span><br><span class="line">	return bytes;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(iov_iter_copy_from_user_atomic);</span><br></pre></td></tr></table></figure>
<p>iov_iter_copy_from_user_atomic的流程图:<br><img src="/2020/01/20/copy-file-range-problem/copy_file_range_iov_iter.png" alt="iov_iter_copy_from_user_atomic"></p>
<blockquote>
<p>iov_iter_copy_from_user_atomic函数并不关心源和目标page是否是同一page，他们之间是否会出现覆盖的情&gt;况，仅仅是执行数据操作。如果数据源和数据目标有覆盖则copy_file_range的结果是有问题的。</p>
</blockquote>
<p>数据覆盖的情况如下图:<br><img src="/2020/01/20/copy-file-range-problem/copy_file_range_overlap.png" alt="iov_iter_copy_from_user_atomic"></p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在使用copy_file_range时一定要注意针对同一文件执行copy_file_range，结果有可能发生覆盖，导致结果并不是我们预期的。这个和memcpy一样，在有覆盖时结果时不可预期的。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://lwn.net/Articles/659523/" target="_blank" rel="noopener">copy_file_range()</a></li>
<li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/read_write.c" target="_blank" rel="noopener">read_write.c</a></li>
</ol>
]]></content>
      <categories>
        <category>ext4</category>
      </categories>
      <tags>
        <tag>fs</tag>
        <tag>ext4</tag>
        <tag>copy_file_range</tag>
      </tags>
  </entry>
  <entry>
    <title>about-dwarf</title>
    <url>/2020/01/20/about-dwarf/</url>
    <content><![CDATA[<h1 id="关于dwarf"><a href="#关于dwarf" class="headerlink" title="关于dwarf"></a>关于dwarf</h1><p>一种调试文件格式，用于支持源码级调试功能。它通过树结构描述一个程序，每个节点有子节点或兄弟节点。节点可以表示<strong>类型</strong>、<strong>变量</strong>、或<strong>函数</strong>。<br>dwarf使用一系列的DIE(debugging information entries)表示源程序。每个<strong>DIE</strong>包含一个tag标签标识和一系列属性。每个或多个DIE组成一组标识程序中某个实体，或是程序或者变量等等。</p>
<h1 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a>readelf</h1><p>readelf –debug-dump=info vmlinux</p>
<blockquote>
<p>输出.debug_info段中调试信息</p>
</blockquote>
<p>下面举个例子。<br><code>readelf --debug-dump=info vmlinux | grep dentry_open</code></p>
<p>通过上面的命令可以得到如下信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">89773762- &lt;1&gt;&lt;aa9c983&gt;: Abbrev Number: 57 (DW_TAG_subprogram)</span><br><span class="line">89773763-    &lt;aa9c984&gt;   DW_AT_external    : 1</span><br><span class="line">89773764-    &lt;aa9c984&gt;   DW_AT_declaration : 1</span><br><span class="line">89773765:    &lt;aa9c984&gt;   DW_AT_linkage_name: (indirect string, offset: 0x105b80): dentry_open</span><br><span class="line">89773766:    &lt;aa9c988&gt;   DW_AT_name        : (indirect string, offset: 0x105b80): dentry_open</span><br><span class="line">89773767-    &lt;aa9c98c&gt;   DW_AT_decl_file   : 55</span><br><span class="line">89773768-    &lt;aa9c98d&gt;   DW_AT_decl_line   : 2493</span><br><span class="line">89773769-    &lt;aa9c98f&gt;   DW_AT_decl_column : 22</span><br></pre></td></tr></table></figure>
<p>dentry_open是一个函数，在2493行被声明的。<br>可以用readelf查看各种信息。<br>在后面的参考中，[2]有对dwarf的详细介绍。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://developer.ibm.com/technologies/systems/articles/au-dwarf-debug-format/" target="_blank" rel="noopener">Exploring the DWARF debug format information</a></li>
<li><a href="http://people.redhat.com/jkratoch/DeveloperConference2011-debug.pdf" target="_blank" rel="noopener">Debugging Tools Intro DWARF,ELF,GDB,build-id</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>nfs cache problem</title>
    <url>/2020/01/20/nfs-cache-problem/</url>
    <content><![CDATA[<h1 id="first-section"><a href="#first-section" class="headerlink" title="first section"></a>first section</h1><p>some content</p>
<h2 id="subsection"><a href="#subsection" class="headerlink" title="subsection"></a>subsection</h2><h1 id="second-section"><a href="#second-section" class="headerlink" title="second section"></a>second section</h1><p>some content<br><em>emphasis</em> <em>emphasis</em><br><strong>emphasis <em>underscore</em></strong><br><del>scratch</del></p>
<h1 id="lists"><a href="#lists" class="headerlink" title="lists"></a>lists</h1><ol>
<li>first</li>
<li>second<br>..* unordered sublist<br>..* unordered sublist</li>
<li>another</li>
<li>the other<br>…some indent here</li>
</ol>
<ul>
<li>unordered list</li>
</ul>
<ul>
<li>minus</li>
</ul>
<ul>
<li>plus</li>
</ul>
<h1 id="links"><a href="#links" class="headerlink" title="links"></a>links</h1><p><a href="http://a.com" target="_blank" rel="noopener">link title</a><br><a href="http://b.com" target="_blank" rel="noopener">link title</a></p>
<h1 id="images"><a href="#images" class="headerlink" title="images"></a>images</h1><p>inline:<br><img src="http://a.com/a.png" alt="some text"></p>
<p>refer:<br><img src="http://a.com/a.png" alt="some text"></p>
<h1 id="code-ang-highlighting"><a href="#code-ang-highlighting" class="headerlink" title="code ang highlighting"></a>code ang highlighting</h1><p>inline <code>code</code>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">some code</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="tables"><a href="#tables" class="headerlink" title="tables"></a>tables</h1><table>
<thead>
<tr>
<th>table</th>
<th align="left">area</th>
<th align="center">cool</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td align="left">as</td>
<td align="center">cool</td>
</tr>
<tr>
<td>b</td>
<td align="left">ad</td>
<td align="center">hot</td>
</tr>
</tbody></table>
<h1 id="blockquotes"><a href="#blockquotes" class="headerlink" title="blockquotes"></a>blockquotes</h1><blockquote>
<p>some content<br>other content</p>
</blockquote>
<h1 id="horizontal-rule"><a href="#horizontal-rule" class="headerlink" title="horizontal rule"></a>horizontal rule</h1><p>maybe<br>…<br>maybe</p>
<hr>
<p>maybe</p>
<hr>
<hr>
<h1 id="line-breaks"><a href="#line-breaks" class="headerlink" title="line breaks"></a>line breaks</h1>]]></content>
      <tags>
        <tag>nfs</tag>
      </tags>
  </entry>
  <entry>
    <title>udplite checksum problem</title>
    <url>/2019/07/16/udplite-checksum-problem/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在linux 3.10.0上面，遇到一个udplite校验失败问题。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>udp报文格式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MAC|IP|UDP|Payload</span><br></pre></td></tr></table></figure>

<p>而如下的udplite报文被drop了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MAC|IP|UDP|Payload</span><br><span class="line">14  20  8   61</span><br><span class="line"></span><br><span class="line">udplite_rcv</span><br><span class="line">-&gt;__udp4_lib_rcv</span><br><span class="line">-&gt;udp4_csum_init</span><br><span class="line">-&gt;udplite_checksum_init</span><br><span class="line">-&gt;skb_checksum_init_zero_check</span><br><span class="line">  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~    报bad checksum</span><br></pre></td></tr></table></figure>

<p>在udplite_checksum_init的开始处:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">skb-&gt;len &#x3D; 61 + 8 &#x3D;69</span><br><span class="line">udphdr-&gt;len &#x3D; 64</span><br></pre></td></tr></table></figure>
<p>UDPLITE协议中，udphdr中len表示对报文多少进行了校验。<br>即UDP_SKB_CB(skb)-&gt;partial_cov=1</p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>udplite</tag>
        <tag>checksum</tag>
      </tags>
  </entry>
  <entry>
    <title>松散源路由发包失败问题</title>
    <url>/2019/06/20/%E6%9D%BE%E6%95%A3%E6%BA%90%E8%B7%AF%E7%94%B1%E5%8F%91%E5%8C%85%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>近期遇到松散源路由报文通信失败，通过systemtap可以很快定位报文丢弃在何处。</p>
<p>直接上探测脚本:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">probe begin()</span><br><span class="line">&#123;</span><br><span class="line">  print(&quot;Begin probe..\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line">probe end()</span><br><span class="line">&#123;</span><br><span class="line">  print(&quot;End probe.\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line">probe kernel.function(&quot;icmp_echo&quot;)</span><br><span class="line">&#123;</span><br><span class="line">  print_backtrace()&#x2F;&#x2F;调用栈回溯</span><br><span class="line">  printf(&quot;%s\n&quot;,pp())&#x2F;&#x2F;调用点</span><br><span class="line">&#125;</span><br><span class="line">probe kernel.statement(&quot;*@net&#x2F;ipv4&#x2F;ip_input.c:341&quot;)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;%s\n&quot;,pp())</span><br><span class="line">&#125;</span><br><span class="line">probe kernel.function(&quot;ip_options_compile&quot;).return</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;ip_options_compile return:%d\n&quot;,$return)</span><br><span class="line">&#125;</span><br><span class="line">probe timer.ms(10000)</span><br><span class="line">&#123;</span><br><span class="line">  exit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在报文路径上增加探测点直接定位出丢包位置。</p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个具体问题是在函数static inline bool ip_rcv_options(struct sk_buff *skb)中如果源路由未打开则直接drop。</p>
<p>打开内核中源路由选项，通信正常。</p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>松散源路由</tag>
        <tag>source route</tag>
      </tags>
  </entry>
</search>
