<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/04/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>hexo hello</category>
      </categories>
      <tags>
        <tag>hello</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>分析一下目前linux内核栈的实现</title>
    <url>/2020/02/27/%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%8B%E7%9B%AE%E5%89%8Dlinux%E5%86%85%E6%A0%B8%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近在看内核一个<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/net/sunrpc/auth_gss/gss_krb5_seqnum.c?h=v5.6-rc3&id=e7afe6c1d486b516ed586dcc10b3e7e3e85a9c2b" target="_blank" rel="noopener">patch</a>的修改，这个patch的commit描述<br>如下:</p>
<blockquote>
<p>While trying to reproduce a reported kernel panic on arm64, I discovered<br>that AUTH_GSS basically doesn’t work at all with older enctypes on arm64<br>systems with CONFIG_VMAP_STACK enabled.  It turns out there still a few<br>places using stack memory with scatterlists, causing krb5_encrypt() and<br>krb5_decrypt() to produce incorrect results (or a BUG if CONFIG_DEBUG_SG<br>is enabled).<br>描述里边提到CONFIG_VMAP_STACK内核宏和scatterlist。下面对它们分析。</p>
</blockquote>
<h2 id="CONFIG-VMAP-STACK"><a href="#CONFIG-VMAP-STACK" class="headerlink" title="CONFIG_VMAP_STACK"></a>CONFIG_VMAP_STACK</h2><h3 id="CONFIG-VMAP-STACK的功能"><a href="#CONFIG-VMAP-STACK的功能" class="headerlink" title="CONFIG_VMAP_STACK的功能"></a>CONFIG_VMAP_STACK的功能</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:&#x2F;share&#x2F;linux# find . -name Kconfig | xargs grep -rsn VMAP_STACK</span><br><span class="line">.&#x2F;arch&#x2F;Kconfig:821:config HAVE_ARCH_VMAP_STACK</span><br><span class="line">.&#x2F;arch&#x2F;Kconfig:841:config VMAP_STACK</span><br><span class="line">.&#x2F;arch&#x2F;Kconfig:844:     depends on HAVE_ARCH_VMAP_STACK</span><br><span class="line">.&#x2F;arch&#x2F;arm64&#x2F;Kconfig:135:       select HAVE_ARCH_VMAP_STACK</span><br><span class="line">.&#x2F;arch&#x2F;s390&#x2F;Kconfig:133:        select HAVE_ARCH_VMAP_STACK</span><br><span class="line">.&#x2F;arch&#x2F;s390&#x2F;Kconfig:714:        depends on !VMAP_STACK</span><br><span class="line">.&#x2F;arch&#x2F;x86&#x2F;Kconfig:152: select HAVE_ARCH_VMAP_STACK             if X86_64</span><br></pre></td></tr></table></figure>
<p>从搜索结果看，这个功能是和架构相关的。<br>再来看下该配置宏的具体描述：</p>
<blockquote>
<p>config VMAP_STACK<br>       default y<br>       bool “Use a virtually-mapped stack”<br>       depends on HAVE_ARCH_VMAP_STACK<br>       depends on !KASAN || KASAN_VMALLOC<br>       —help—<br>         Enable this if you want the use virtually-mapped kernel stacks<br>         with guard pages.  This causes kernel stack overflows to be<br>         caught immediately rather than causing difficult-to-diagnose<br>         corruption.</p>
<pre><code>To use this with KASAN, the architecture must support backing
virtual mappings with real shadow memory, and KASAN_VMALLOC must
 be enabled.</code></pre></blockquote>
<p>如果内核开启CONFIG_VMAP_STACK，内核可以快速检测内核栈overflow异常，比之前在内核栈溢出<br>访问时出问题难以诊断，内核栈溢出肯定访问垃圾数据，其结果不可预测的，难以排查，在有个guardpage后<br>只要内核栈溢出访问，内核可以快速捕获到。</p>
<p>内核栈的申请通过alloc_thread_stack_node实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static unsigned long *alloc_thread_stack_node(struct task_struct *tsk, int node)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef CONFIG_VMAP_STACK</span><br><span class="line">        void *stack;</span><br><span class="line">        int i;</span><br><span class="line"></span><br><span class="line">        for (i &#x3D; 0; i &lt; NR_CACHED_STACKS; i++) &#123;</span><br><span class="line">                struct vm_struct *s;</span><br><span class="line"></span><br><span class="line">                s &#x3D; this_cpu_xchg(cached_stacks[i], NULL);</span><br><span class="line"></span><br><span class="line">                if (!s)</span><br><span class="line">                        continue;</span><br><span class="line"></span><br><span class="line">                &#x2F;* Clear the KASAN shadow of the stack. *&#x2F;</span><br><span class="line">                kasan_unpoison_shadow(s-&gt;addr, THREAD_SIZE);</span><br><span class="line"></span><br><span class="line">                &#x2F;* Clear stale pointers from reused stack. *&#x2F;</span><br><span class="line">                memset(s-&gt;addr, 0, THREAD_SIZE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                tsk-&gt;stack_vm_area &#x3D; s;</span><br><span class="line">                tsk-&gt;stack &#x3D; s-&gt;addr;</span><br><span class="line">                return s-&gt;addr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">         * Allocated stacks are cached and later reused by new threads,</span><br><span class="line">         * so memcg accounting is performed manually on assigning&#x2F;releasing</span><br><span class="line">         * stacks to tasks. Drop __GFP_ACCOUNT.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        stack &#x3D; __vmalloc_node_range(THREAD_SIZE, THREAD_ALIGN,</span><br><span class="line">                                     VMALLOC_START, VMALLOC_END,</span><br><span class="line">                                     THREADINFO_GFP &amp; ~__GFP_ACCOUNT,</span><br><span class="line">                                     PAGE_KERNEL,</span><br><span class="line">                                     0, node, __builtin_return_address(0));</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * We can&#39;t call find_vm_area() in interrupt context, and</span><br><span class="line">         * free_thread_stack() can be called in interrupt context,</span><br><span class="line">         * so cache the vm_struct.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if (stack) &#123;</span><br><span class="line">                tsk-&gt;stack_vm_area &#x3D; find_vm_area(stack);</span><br><span class="line">                tsk-&gt;stack &#x3D; stack;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack;</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line">        struct page *page &#x3D; alloc_pages_node(node, THREADINFO_GFP,</span><br><span class="line">                                             THREAD_SIZE_ORDER);</span><br><span class="line"></span><br><span class="line">        if (likely(page)) &#123;</span><br><span class="line">                tsk-&gt;stack &#x3D; page_address(page);</span><br><span class="line">                return tsk-&gt;stack;</span><br><span class="line">        &#125;</span><br><span class="line">        return NULL;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免vmalloc的频繁调用，内核使用cached_stacks本地缓存数组，保存进程退出时的内核栈指针。在<br>创建进程时可以直接从cached_stacks本地缓存数组获取可用的内核栈。</p>
<p>如果cached_stacks本地缓存数组不可用，则通过vmalloc接口申请内核栈。vmalloc申请的空间并不保证是<br>物理连续的页。</p>
<p>vmalloc申请的空间在使用上要注意：</p>
<ol>
<li>不能用于DMA操作<blockquote>
<p>DMA硬件没有页面映射，需要物理上连续的空间。</p>
</blockquote>
</li>
<li>不能用于scatterlist<blockquote>
<p>后面分析</p>
</blockquote>
</li>
</ol>
<p>在不启用CONFIG_VMAP_STACK时，内核使用alloc_pages_node申请内核栈空间。这个接口申请连续的物理页<br>作为内核栈。</p>
<h3 id="内核栈大小"><a href="#内核栈大小" class="headerlink" title="内核栈大小"></a>内核栈大小</h3><p>前面分析了内核栈的分配，那么内核栈占多少空间呢？</p>
<blockquote>
<p>THREAD_SIZE宏定义了内核栈的大小。</p>
</blockquote>
<p>THREAD_SIZE是架构相关的，在x86上定义为2个page的大小。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define THREAD_SIZE_ORDER       1</span><br><span class="line">#define THREAD_SIZE             (PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)</span><br></pre></td></tr></table></figure>

<p>在x86_64上定义为如下大小，开启KASAN，则分配8个page的大小，不开启KSASAN则定义为4个page的大小。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifdef CONFIG_KASAN</span><br><span class="line">#define KASAN_STACK_ORDER 1</span><br><span class="line">#else</span><br><span class="line">#define KASAN_STACK_ORDER 0</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define THREAD_SIZE_ORDER       (2 + KASAN_STACK_ORDER)</span><br><span class="line">#define THREAD_SIZE  (PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)</span><br></pre></td></tr></table></figure>

<p>这里提高了KASAN功能，这个是什么功能呢？</p>
<blockquote>
<p>Kasan 是 Kernel Address Sanitizer 的缩写，它是一个动态检测内存错误的工具，主要功能是<br>检查内存越界访问和使用已释放的内存等问题。Kasan 集成在 Linux 内核中，随 Linux 内核<br>代码一起发布，并由内核社区维护和发展。</p>
</blockquote>
<p>这里不对KASAN功能进行分析，更多的可以参考下面的文档。<br>KASAN扩展阅读</p>
<ol>
<li><a href="https://www.kernel.org/doc/html/v4.14/dev-tools/kasan.html" target="_blank" rel="noopener">KASAN内核文档</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/1608_tengr_kasan/index.html" target="_blank" rel="noopener">KASAN简单介绍</a></li>
</ol>
<h3 id="内核栈的布局"><a href="#内核栈的布局" class="headerlink" title="内核栈的布局"></a>内核栈的布局</h3><p>内核栈布局和架构相关，x86配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat arch&#x2F;x86&#x2F;Kconfig</span><br><span class="line">config X86</span><br><span class="line">        def_bool y</span><br><span class="line">		...</span><br><span class="line">		select THREAD_INFO_IN_TASK</span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">$ cat include&#x2F;linux&#x2F;sched.h</span><br><span class="line">struct task_struct &#123;</span><br><span class="line">#ifdef CONFIG_THREAD_INFO_IN_TASK</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * For reasons of header soup (see current_thread_info()), this</span><br><span class="line">         * must be the first element of task_struct.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        struct thread_info              thread_info;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>由上可见在x86上，内核栈就是单纯的内核栈，thread_info结构不在内核栈的低端地址上，而是移到了task_struct结构中，这样好处是<br>内核栈溢出时不会破坏thread_info结构，更加安全。</p>
<p>之前内核栈的布局是这样的，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">high address                low address </span><br><span class="line">|----------------------|&lt;--------&gt;|</span><br><span class="line">                        thread_info</span><br></pre></td></tr></table></figure>

<h2 id="scatterlist"><a href="#scatterlist" class="headerlink" title="scatterlist"></a>scatterlist</h2><p>scatterlist用来描述一内存段，其结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct scatterlist &#123;</span><br><span class="line">        unsigned long   page_link;</span><br><span class="line">        unsigned int    offset;</span><br><span class="line">        unsigned int    length;</span><br><span class="line">        dma_addr_t      dma_address;</span><br><span class="line">#ifdef CONFIG_NEED_SG_DMA_LENGTH</span><br><span class="line">        unsigned int    dma_length;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>page_link是page指针，这里复用该page指针使其支持<a href="https://lwn.net/Articles/234617/" target="_blank" rel="noopener">scatterlist chain</a>。<br>每个scatterlist描述一个物理页的内存片段。</p>
<p>为何vmalloc空间不能用于scatterlist呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         vmalloc buffer</span><br><span class="line">          |-------------|</span><br><span class="line">|-------------|-----------|</span><br><span class="line">        pageX	       pageY</span><br></pre></td></tr></table></figure>
<p>如果vmalloc buffer跨page边界，看会发生什么。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat net&#x2F;sunrpc&#x2F;auth_gss&#x2F;gss_krb5_crypto.c</span><br><span class="line">u32</span><br><span class="line">krb5_encrypt(</span><br><span class="line">        struct crypto_sync_skcipher *tfm,</span><br><span class="line">        void * iv,</span><br><span class="line">        void * in,</span><br><span class="line">        void * out,</span><br><span class="line">        int length)</span><br><span class="line">&#123;</span><br><span class="line">        u32 ret &#x3D; -EINVAL;</span><br><span class="line">        struct scatterlist sg[1];</span><br><span class="line">		...</span><br><span class="line">		memcpy(out, in, length);</span><br><span class="line">        sg_init_one(sg, out, length);</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br><span class="line">$ cat lib&#x2F;scatterlist.c</span><br><span class="line">void sg_init_one(struct scatterlist *sg, const void *buf, unsigned int buflen)</span><br><span class="line">&#123;</span><br><span class="line">        sg_init_table(sg, 1);</span><br><span class="line">        sg_set_buf(sg, buf, buflen);</span><br><span class="line">&#125;</span><br><span class="line">$ cat include&#x2F;linux&#x2F;scatterlist.h</span><br><span class="line">static inline void sg_set_buf(struct scatterlist *sg, const void *buf,</span><br><span class="line">			      unsigned int buflen)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef CONFIG_DEBUG_SG</span><br><span class="line">	BUG_ON(!virt_addr_valid(buf));</span><br><span class="line">#endif</span><br><span class="line">	sg_set_page(sg, virt_to_page(buf), buflen, offset_in_page(buf));</span><br><span class="line">&#125;</span><br><span class="line">$ cat include&#x2F;linux&#x2F;scatterlist.h</span><br><span class="line">static inline void sg_set_page(struct scatterlist *sg, struct page *page,</span><br><span class="line">			       unsigned int len, unsigned int offset)</span><br><span class="line">&#123;</span><br><span class="line">	sg_assign_page(sg, page);</span><br><span class="line">	sg-&gt;offset &#x3D; offset;</span><br><span class="line">	sg-&gt;length &#x3D; len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在sg_set_page后，scatterlist只记录了pageX，后面的pageY是没有记录的，后面使用scatterlist时<br>可能访问到垃圾数据。可见vmalloc空间时不能用于scatterlist的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文分析了CONFIG_VMAP_STACK和scatterlist的功能，在使能CONFIG_VMAP_STACK后，内核栈上分配的<br>空间是物理上不连续的，不能用于scatterlist，不能用于DMA。</p>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>内核栈</tag>
        <tag>CONFIG_VMAP_STACK</tag>
        <tag>scatterlist</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu清理磁盘空间</title>
    <url>/2020/02/25/ubuntu%E6%B8%85%E7%90%86%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>虽然linux不像windows那样需要碎片整理，随着时间的流逝，硬盘空间会<br>越来越小，有必要对硬件空间清理。以ubuntu为例说明如何清理硬盘空间。</p>
<h2 id="查看硬盘占用"><a href="#查看硬盘占用" class="headerlink" title="查看硬盘占用"></a>查看硬盘占用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            934M     0  934M   0% &#x2F;dev</span><br><span class="line">tmpfs           193M  2.6M  191M   2% &#x2F;run</span><br><span class="line">&#x2F;dev&#x2F;sda1       8.8G  6.5G  1.9G  78% &#x2F;</span><br><span class="line">tmpfs           965M     0  965M   0% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% &#x2F;run&#x2F;lock</span><br><span class="line">tmpfs           965M     0  965M   0% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">tmpfs           193M     0  193M   0% &#x2F;run&#x2F;user&#x2F;0</span><br><span class="line">tmpfs           193M     0  193M   0% &#x2F;run&#x2F;user&#x2F;1000</span><br><span class="line">&#x2F;dev&#x2F;sdb1       127G  3.0G  125G   3% &#x2F;share</span><br></pre></td></tr></table></figure>
<p>这里根分区可用空间不足，需要对根分区下目录空间占用进行分析。</p>
<h2 id="查看根分区目录空间占用"><a href="#查看根分区目录空间占用" class="headerlink" title="查看根分区目录空间占用"></a>查看根分区目录空间占用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ du -h --max-depth&#x3D;1 &#x2F;</span><br><span class="line">23M	&#x2F;opt</span><br><span class="line">0	&#x2F;dev</span><br><span class="line">236M	&#x2F;boot</span><br><span class="line">8.0K	&#x2F;snap</span><br><span class="line">5.8M	&#x2F;lib32</span><br><span class="line">3.1G	&#x2F;usr</span><br><span class="line">0	&#x2F;sys</span><br><span class="line">156M	&#x2F;root</span><br><span class="line">16K	&#x2F;lost+found</span><br><span class="line">0	&#x2F;proc</span><br><span class="line">12K	&#x2F;media</span><br><span class="line">4.0K	&#x2F;srv</span><br><span class="line">6.5M	&#x2F;libx32</span><br><span class="line">4.0K	&#x2F;lib64</span><br><span class="line">4.0K	&#x2F;mnt</span><br><span class="line">12M	&#x2F;etc</span><br><span class="line">1.1G	&#x2F;lib</span><br><span class="line">2.8G	&#x2F;share</span><br><span class="line">704M	&#x2F;var</span><br><span class="line">2.9M	&#x2F;run</span><br><span class="line">18M	&#x2F;bin</span><br><span class="line">1.1G	&#x2F;home</span><br><span class="line">19M	&#x2F;sbin</span><br><span class="line">48K	&#x2F;tmp</span><br><span class="line">4.0K	&#x2F;nextcloud</span><br><span class="line">9.2G	&#x2F;</span><br></pre></td></tr></table></figure>

<p>随着时间的流逝，log目录会比较大，可以通过journalctl命令控制日志文件所占空<br>间的大小。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ journalctl --vaccum-size&#x3D;100M</span><br></pre></td></tr></table></figure>

<h1 id="清空安装的软件包备份"><a href="#清空安装的软件包备份" class="headerlink" title="清空安装的软件包备份"></a>清空安装的软件包备份</h1><p>ubuntu把安装的软件包缓存在如下目录:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F;</span><br><span class="line">lock partial</span><br></pre></td></tr></table></figure>

<p>然后通过下面的命令删除缓存的安装包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ apt clean</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过以上步骤，硬盘空间大了许多。</p>
]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>copy_file_range problem</title>
    <url>/2020/01/20/copy-file-range-problem/</url>
    <content><![CDATA[<h1 id="copy-file-range问题"><a href="#copy-file-range问题" class="headerlink" title="copy_file_range问题"></a>copy_file_range问题</h1><p>在使用3.10内核的过程中遇到一个关于copy_file_range的问题，<strong>拷贝后数据不对</strong>。有必要对这个系统调用分析一下。</p>
<h1 id="copy-file-range"><a href="#copy-file-range" class="headerlink" title="copy_file_range"></a>copy_file_range</h1><p><strong>copy_file_range</strong>是最近新增的[2]syscall，在不需要内核和用户态缓存间的拷贝就可以高效实现文件间的拷贝。传统的文件拷贝流程涉及内核page cache到用户缓存，然后由用户缓存再拷贝到内核page cache，中间涉及两次拷贝，效率不高。copy_file_range正是对拷贝的优化，内部实现是通过pipe buffer的结构，在读取源文件时把涉及到的page cache内存页，页内offset，长度信息，保存到pipe buffer中，在向目标文件拷贝时直接读取pipe buffer信息，执行后续写操作，这样仅需要一次拷贝就完成了。</p>
<p>copy_file_range的流程图如下<br><img src="/2020/01/20/copy-file-range-problem/copy_file_range_ext4.png" alt="copy_file_range flow chart"><br>可以看到最终调用pipe_to_file。下面看下该函数的实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe_to_file</span><span class="params">(struct pipe_inode_info *pipe, struct pipe_buffer *buf,</span></span></span><br><span class="line"><span class="function"><span class="params">struct splice_desc *sd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> = <span class="title">sd</span>-&gt;<span class="title">u</span>.<span class="title">file</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> = <span class="title">file</span>-&gt;<span class="title">f_mapping</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> offset, this_len;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="keyword">void</span> *fsdata;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	offset = sd-&gt;pos &amp; ~PAGE_CACHE_MASK;</span><br><span class="line"></span><br><span class="line">	this_len = sd-&gt;len;</span><br><span class="line">	<span class="keyword">if</span> (this_len + offset &gt; PAGE_CACHE_SIZE)</span><br><span class="line">		this_len = PAGE_CACHE_SIZE - offset;</span><br><span class="line"></span><br><span class="line">	ret = pagecache_write_begin(file, mapping, sd-&gt;pos, this_len,</span><br><span class="line">	AOP_FLAG_UNINTERRUPTIBLE, &amp;page, &amp;fsdata);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(ret))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (buf-&gt;page != page) &#123;</span><br><span class="line">		<span class="keyword">char</span> *src = buf-&gt;ops-&gt;<span class="built_in">map</span>(pipe, buf, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">char</span> *dst = kmap_atomic(page);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memcpy</span>(dst + offset, src + buf-&gt;offset, this_len);</span><br><span class="line">		flush_dcache_page(page);</span><br><span class="line">		kunmap_atomic(dst);</span><br><span class="line">		buf-&gt;ops-&gt;unmap(pipe, buf, src);</span><br><span class="line">	&#125;</span><br><span class="line">	ret = pagecache_write_end(file, mapping, sd-&gt;pos, this_len, this_len,</span><br><span class="line">		page, fsdata);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面第22行判断如果不是同一page时才会执行数据拷贝操作，如果是同一page，则不执行数据操作。这样copy_file_range就不适用同一文件中拷贝。如果执行copy_file_range测试指定的是同一文件，在源偏移和目标偏移很小，即小于一个page大小时，pipe_to_file就不执行数据操作，从而导致拷贝数据不一致。</p>
<p>内核upstream上的处理流程如下图:<br><img src="/2020/01/20/copy-file-range-problem/copy_file_range_ext4_latest.png" alt="cop_file_range"></p>
<blockquote>
<p>最新版的内核已经抛弃对pipe_to_file的调用，该函数也已经从内核移除。最终的实现调用的是iov_iter_copy_from_user_atomic负责完成数据操作。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">size_t iov_iter_copy_from_user_atomic(struct page *page,</span><br><span class="line">struct iov_iter *i, unsigned long offset, size_t bytes)</span><br><span class="line">&#123;</span><br><span class="line">	char *kaddr &#x3D; kmap_atomic(page), *p &#x3D; kaddr + offset;</span><br><span class="line">	if (unlikely(!page_copy_sane(page, offset, bytes))) &#123;</span><br><span class="line">		kunmap_atomic(kaddr);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	if (unlikely(iov_iter_is_pipe(i) || iov_iter_is_discard(i))) &#123;</span><br><span class="line">		kunmap_atomic(kaddr);</span><br><span class="line">		WARN_ON(1);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	iterate_all_kinds(i, bytes, v,</span><br><span class="line">		copyin((p +&#x3D; v.iov_len) - v.iov_len, v.iov_base, v.iov_len),</span><br><span class="line">		memcpy_from_page((p +&#x3D; v.bv_len) - v.bv_len, v.bv_page,v.bv_offset, v.bv_len),</span><br><span class="line">		memcpy((p +&#x3D; v.iov_len) - v.iov_len, v.iov_base, v.iov_len)</span><br><span class="line">	)</span><br><span class="line">	kunmap_atomic(kaddr);</span><br><span class="line">	return bytes;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(iov_iter_copy_from_user_atomic);</span><br></pre></td></tr></table></figure>
<p>iov_iter_copy_from_user_atomic的流程图:<br><img src="/2020/01/20/copy-file-range-problem/copy_file_range_iov_iter.png" alt="iov_iter_copy_from_user_atomic"></p>
<blockquote>
<p>iov_iter_copy_from_user_atomic函数并不关心源和目标page是否是同一page，他们之间是否会出现覆盖的情&gt;况，仅仅是执行数据操作。如果数据源和数据目标有覆盖则copy_file_range的结果是有问题的。</p>
</blockquote>
<p>数据覆盖的情况如下图:<br><img src="/2020/01/20/copy-file-range-problem/copy_file_range_overlap.png" alt="iov_iter_copy_from_user_atomic"></p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在使用copy_file_range时一定要注意针对同一文件执行copy_file_range，结果有可能发生覆盖，导致结果并不是我们预期的。这个和memcpy一样，在有覆盖时结果时不可预期的。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://lwn.net/Articles/659523/" target="_blank" rel="noopener">copy_file_range()</a></li>
<li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/read_write.c" target="_blank" rel="noopener">read_write.c</a></li>
</ol>
]]></content>
      <categories>
        <category>ext4</category>
      </categories>
      <tags>
        <tag>fs</tag>
        <tag>ext4</tag>
        <tag>copy_file_range</tag>
      </tags>
  </entry>
  <entry>
    <title>about-dwarf</title>
    <url>/2020/01/20/about-dwarf/</url>
    <content><![CDATA[<h1 id="关于dwarf"><a href="#关于dwarf" class="headerlink" title="关于dwarf"></a>关于dwarf</h1><p>一种调试文件格式，用于支持源码级调试功能。它通过树结构描述一个程序，每个节点有子节点或兄弟节点。节点可以表示<strong>类型</strong>、<strong>变量</strong>、或<strong>函数</strong>。<br>dwarf使用一系列的DIE(debugging information entries)表示源程序。每个<strong>DIE</strong>包含一个tag标签标识和一系列属性。每个或多个DIE组成一组标识程序中某个实体，或是程序或者变量等等。</p>
<h1 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a>readelf</h1><p>readelf –debug-dump=info vmlinux</p>
<blockquote>
<p>输出.debug_info段中调试信息</p>
</blockquote>
<p>下面举个例子。<br><code>readelf --debug-dump=info vmlinux | grep dentry_open</code></p>
<p>通过上面的命令可以得到如下信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">89773762- &lt;1&gt;&lt;aa9c983&gt;: Abbrev Number: 57 (DW_TAG_subprogram)</span><br><span class="line">89773763-    &lt;aa9c984&gt;   DW_AT_external    : 1</span><br><span class="line">89773764-    &lt;aa9c984&gt;   DW_AT_declaration : 1</span><br><span class="line">89773765:    &lt;aa9c984&gt;   DW_AT_linkage_name: (indirect string, offset: 0x105b80): dentry_open</span><br><span class="line">89773766:    &lt;aa9c988&gt;   DW_AT_name        : (indirect string, offset: 0x105b80): dentry_open</span><br><span class="line">89773767-    &lt;aa9c98c&gt;   DW_AT_decl_file   : 55</span><br><span class="line">89773768-    &lt;aa9c98d&gt;   DW_AT_decl_line   : 2493</span><br><span class="line">89773769-    &lt;aa9c98f&gt;   DW_AT_decl_column : 22</span><br></pre></td></tr></table></figure>
<p>dentry_open是一个函数，在2493行被声明的。<br>可以用readelf查看各种信息。<br>在后面的参考中，[2]有对dwarf的详细介绍。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://developer.ibm.com/technologies/systems/articles/au-dwarf-debug-format/" target="_blank" rel="noopener">Exploring the DWARF debug format information</a></li>
<li><a href="http://people.redhat.com/jkratoch/DeveloperConference2011-debug.pdf" target="_blank" rel="noopener">Debugging Tools Intro DWARF,ELF,GDB,build-id</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>nfs cache problem</title>
    <url>/2020/01/20/nfs-cache-problem/</url>
    <content><![CDATA[<h1 id="first-section"><a href="#first-section" class="headerlink" title="first section"></a>first section</h1><p>some content</p>
<h2 id="subsection"><a href="#subsection" class="headerlink" title="subsection"></a>subsection</h2><h1 id="second-section"><a href="#second-section" class="headerlink" title="second section"></a>second section</h1><p>some content<br><em>emphasis</em> <em>emphasis</em><br><strong>emphasis <em>underscore</em></strong><br><del>scratch</del></p>
<h1 id="lists"><a href="#lists" class="headerlink" title="lists"></a>lists</h1><ol>
<li>first</li>
<li>second<br>..* unordered sublist<br>..* unordered sublist</li>
<li>another</li>
<li>the other<br>…some indent here</li>
</ol>
<ul>
<li>unordered list</li>
</ul>
<ul>
<li>minus</li>
</ul>
<ul>
<li>plus</li>
</ul>
<h1 id="links"><a href="#links" class="headerlink" title="links"></a>links</h1><p><a href="http://a.com" target="_blank" rel="noopener">link title</a><br><a href="http://b.com" target="_blank" rel="noopener">link title</a></p>
<h1 id="images"><a href="#images" class="headerlink" title="images"></a>images</h1><p>inline:<br><img src="http://a.com/a.png" alt="some text"></p>
<p>refer:<br><img src="http://a.com/a.png" alt="some text"></p>
<h1 id="code-ang-highlighting"><a href="#code-ang-highlighting" class="headerlink" title="code ang highlighting"></a>code ang highlighting</h1><p>inline <code>code</code>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">some code</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="tables"><a href="#tables" class="headerlink" title="tables"></a>tables</h1><table>
<thead>
<tr>
<th>table</th>
<th align="left">area</th>
<th align="center">cool</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td align="left">as</td>
<td align="center">cool</td>
</tr>
<tr>
<td>b</td>
<td align="left">ad</td>
<td align="center">hot</td>
</tr>
</tbody></table>
<h1 id="blockquotes"><a href="#blockquotes" class="headerlink" title="blockquotes"></a>blockquotes</h1><blockquote>
<p>some content<br>other content</p>
</blockquote>
<h1 id="horizontal-rule"><a href="#horizontal-rule" class="headerlink" title="horizontal rule"></a>horizontal rule</h1><p>maybe<br>…<br>maybe</p>
<hr>
<p>maybe</p>
<hr>
<hr>
<h1 id="line-breaks"><a href="#line-breaks" class="headerlink" title="line breaks"></a>line breaks</h1>]]></content>
      <tags>
        <tag>nfs</tag>
      </tags>
  </entry>
  <entry>
    <title>udplite checksum problem</title>
    <url>/2019/07/16/udplite-checksum-problem/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在linux 3.10.0上面，遇到一个udplite校验失败问题。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>udp报文格式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MAC|IP|UDP|Payload</span><br></pre></td></tr></table></figure>

<p>而如下的udplite报文被drop了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MAC|IP|UDP|Payload</span><br><span class="line">14  20  8   61</span><br><span class="line"></span><br><span class="line">udplite_rcv</span><br><span class="line">-&gt;__udp4_lib_rcv</span><br><span class="line">-&gt;udp4_csum_init</span><br><span class="line">-&gt;udplite_checksum_init</span><br><span class="line">-&gt;skb_checksum_init_zero_check</span><br><span class="line">  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~    报bad checksum</span><br></pre></td></tr></table></figure>

<p>在udplite_checksum_init的开始处:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">skb-&gt;len &#x3D; 61 + 8 &#x3D;69</span><br><span class="line">udphdr-&gt;len &#x3D; 64</span><br></pre></td></tr></table></figure>
<p>UDPLITE协议中，udphdr中len表示对报文多少进行了校验。<br>即UDP_SKB_CB(skb)-&gt;partial_cov=1</p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>udplite</tag>
        <tag>checksum</tag>
      </tags>
  </entry>
  <entry>
    <title>松散源路由发包失败问题</title>
    <url>/2019/06/20/%E6%9D%BE%E6%95%A3%E6%BA%90%E8%B7%AF%E7%94%B1%E5%8F%91%E5%8C%85%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>近期遇到松散源路由报文通信失败，通过systemtap可以很快定位报文丢弃在何处。</p>
<p>直接上探测脚本:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">probe begin()</span><br><span class="line">&#123;</span><br><span class="line">  print(&quot;Begin probe..\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line">probe end()</span><br><span class="line">&#123;</span><br><span class="line">  print(&quot;End probe.\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line">probe kernel.function(&quot;icmp_echo&quot;)</span><br><span class="line">&#123;</span><br><span class="line">  print_backtrace()&#x2F;&#x2F;调用栈回溯</span><br><span class="line">  printf(&quot;%s\n&quot;,pp())&#x2F;&#x2F;调用点</span><br><span class="line">&#125;</span><br><span class="line">probe kernel.statement(&quot;*@net&#x2F;ipv4&#x2F;ip_input.c:341&quot;)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;%s\n&quot;,pp())</span><br><span class="line">&#125;</span><br><span class="line">probe kernel.function(&quot;ip_options_compile&quot;).return</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;ip_options_compile return:%d\n&quot;,$return)</span><br><span class="line">&#125;</span><br><span class="line">probe timer.ms(10000)</span><br><span class="line">&#123;</span><br><span class="line">  exit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在报文路径上增加探测点直接定位出丢包位置。</p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个具体问题是在函数static inline bool ip_rcv_options(struct sk_buff *skb)中如果源路由未打开则直接drop。</p>
<p>打开内核中源路由选项，通信正常。</p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>松散源路由</tag>
        <tag>source route</tag>
      </tags>
  </entry>
  <entry>
    <title>x86_64 calling conventions</title>
    <url>/2019/06/10/x86_64%20calling%20conversion/</url>
    <content><![CDATA[<p>在分析异常调用栈需要了解参数传递细节，在这里整理一下x86_64调用约定。</p>
<h2 id="通过函数的汇编语句分析调用约定"><a href="#通过函数的汇编语句分析调用约定" class="headerlink" title="通过函数的汇编语句分析调用约定"></a>通过函数的汇编语句分析调用约定</h2><h3 id="栈帧布局"><a href="#栈帧布局" class="headerlink" title="栈帧布局"></a>栈帧布局</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line"> foo:</span><br><span class="line">     push %rbp</span><br><span class="line">     mov %rsp,%rbp</span><br><span class="line">     …</span><br><span class="line"> [retaddr][old rbp]</span><br><span class="line">                  ^</span><br><span class="line">                  |</span><br><span class="line">                rbp&#x2F;rsp</span><br><span class="line"> 8(%rbp): return address</span><br><span class="line"> 0(%rbp): old %rbp</span><br></pre></td></tr></table></figure>

<p>上面是foo函数的汇编语句，在函数入口处，%rsp指向返回地址，重新设置%rbp指向当前栈帧。</p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo:</span><br><span class="line">     push %rbp</span><br><span class="line">     mov %rsp,%rbp</span><br><span class="line">     sub $16,%rsp # local var spaces</span><br><span class="line">     …</span><br><span class="line"> [retaddr][old rbp][local vars]</span><br><span class="line">high addr         ^           ^ low addr</span><br><span class="line">                  |           |</span><br><span class="line">                 rbp         rsp</span><br><span class="line"> -8(%rbp):local vars</span><br></pre></td></tr></table></figure>

<p>如果在栈上分配局部变量，通过%rbp访问。-8(%rbp)访问第一个局部变量，依次类推访问其它局部变量。</p>
<h3 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo:</span><br><span class="line">     push %rbp</span><br><span class="line">     mov %rsp,%rbp</span><br><span class="line">     sub $16,%rsp # local var spaces</span><br><span class="line">     ...</span><br><span class="line">     add $16,%rsp # balance stack</span><br><span class="line">     pop %rbp  # restore stack frame pointer</span><br><span class="line">     ret # return to caller</span><br><span class="line"> [retaddr][old rbp][local vars]</span><br><span class="line">                  ^           ^</span><br><span class="line">                  |           |</span><br><span class="line">                 rbp         rsp</span><br><span class="line"> -8(%rbp):local vars</span><br></pre></td></tr></table></figure>

<p>在使用完局部变量需要把对应栈空间释放，平衡堆栈，最后ret返回caller处。</p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call conventions:</span><br><span class="line"> void foo(int a,int b,int c,int d,int e,int f,int g);</span><br><span class="line">   40053c:       6a 07                   pushq  $0x7      # seventh use stack</span><br><span class="line">   40053e:       41 b9 06 00 00 00       mov    $0x6,%r9d # sixth</span><br><span class="line">   400544:       41 b8 05 00 00 00       mov    $0x5,%r8d # fifth</span><br><span class="line">   40054a:       b9 04 00 00 00          mov    $0x4,%ecx # fouth</span><br><span class="line">   40054f:       ba 03 00 00 00          mov    $0x3,%edx # third</span><br><span class="line">   400554:       be 02 00 00 00          mov    $0x2,%esi # second para</span><br><span class="line">   400559:       bf 01 00 00 00          mov    $0x1,%edi # first para</span><br><span class="line"> %rdi -&gt;a</span><br><span class="line"> %rsi -&gt;b</span><br><span class="line"> %rdx -&gt;c</span><br><span class="line"> %rcx -&gt;d</span><br><span class="line"> %r8  -&gt;e</span><br><span class="line"> %r9  -&gt;f</span><br><span class="line"> [parameters][retaddr][old rbp]</span><br><span class="line">                              ^</span><br><span class="line">                              |</span><br><span class="line">                             rbp&#x2F;rsp    </span><br><span class="line"> 8(%rbp): return address</span><br><span class="line"> 16(%rbp): the seventh parameter</span><br><span class="line"> 24(%rbp): the eighth parameter</span><br></pre></td></tr></table></figure>

<p>前6个参数使用寄存器传递，如果还有额外参数则通过堆栈传递。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://en.wikipedia.org/wiki/X86_calling_conventions" target="_blank" rel="noopener">X86_calling_conventions</a></li>
<li><a href="https://aaronbloomfield.github.io/pdr/book/x86-64bit-ccc-chapter.pdf" target="_blank" rel="noopener">The 64 bit x86 C Calling Convention</a></li>
</ol>
]]></content>
      <categories>
        <category>调用约定</category>
      </categories>
      <tags>
        <tag>x86_64</tag>
        <tag>调用约定</tag>
      </tags>
  </entry>
  <entry>
    <title>sctp中一个bug</title>
    <url>/2019/06/04/sctp%E4%B8%AD%E4%B8%80%E4%B8%AAbug%E7%9A%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>syzkaller是Google团队开发的一款针对Linux内核进行模糊测试的开源工具,目前还在不断的维护之中。<br>订阅了相关linux内核的邮件列表后，会收到google的sykaller发现的内核bug的相关报告。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello,</span><br><span class="line"> syzbot found the following crash on:</span><br><span class="line"> HEAD commit:    9221dced Merge tag &#39;for-linus-20190601&#39; of git:&#x2F;&#x2F;git.kerne..</span><br><span class="line"> git tree:       upstream</span><br><span class="line"> console output: https:&#x2F;&#x2F;syzkaller.appspot.com&#x2F;x&#x2F;log.txt?x&#x3D;114cdc0ea00000</span><br><span class="line"> kernel config:  https:&#x2F;&#x2F;syzkaller.appspot.com&#x2F;x&#x2F;.config?x&#x3D;1fa7e451a5cac069</span><br><span class="line"> dashboard link: https:&#x2F;&#x2F;syzkaller.appspot.com&#x2F;bug?extid&#x3D;a9e23ea2aa21044c2798</span><br><span class="line"> compiler:       gcc (GCC) 9.0.0 20181231 (experimental)</span><br><span class="line"> userspace arch: i386</span><br><span class="line"> Unfortunately, I don&#39;t have any reproducer for this crash yet.</span><br><span class="line"> IMPORTANT: if you fix the bug, please add the following tag to the commit:</span><br><span class="line"> Reported-by: syzbot+a9e23ea2aa21044c2798@syzkaller.appspotmail.com</span><br><span class="line"> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> BUG: KASAN: slab-out-of-bounds in rt_cache_valid+0x158&#x2F;0x190</span><br><span class="line"> net&#x2F;ipv4&#x2F;route.c:1556</span><br><span class="line"> Read of size 2 at addr ffff8880654f3ac7 by task syz-executor.0&#x2F;26603</span><br><span class="line"> CPU: 0 PID: 26603 Comm: syz-executor.0 Not tainted 5.2.0-rc2+ #9 Hardware name: Google Google Compute Engine&#x2F;Google Compute Engine, BIOS Google 01&#x2F;01&#x2F;2011 Call Trace:</span><br><span class="line">   __dump_stack lib&#x2F;dump_stack.c:77 [inline]</span><br><span class="line">   dump_stack+0x172&#x2F;0x1f0 lib&#x2F;dump_stack.c:113</span><br><span class="line">   print_address_description.cold+0x7c&#x2F;0x20d mm&#x2F;kasan&#x2F;report.c:188</span><br><span class="line">   __kasan_report.cold+0x1b&#x2F;0x40 mm&#x2F;kasan&#x2F;report.c:317</span><br><span class="line">   kasan_report+0x12&#x2F;0x20 mm&#x2F;kasan&#x2F;common.c:614</span><br><span class="line">   __asan_report_load2_noabort+0x14&#x2F;0x20 mm&#x2F;kasan&#x2F;generic_report.c:130</span><br><span class="line">   rt_cache_valid+0x158&#x2F;0x190 net&#x2F;ipv4&#x2F;route.c:1556</span><br><span class="line">   __mkroute_output net&#x2F;ipv4&#x2F;route.c:2332 [inline]</span><br><span class="line">   ip_route_output_key_hash_rcu+0x819&#x2F;0x2d50 net&#x2F;ipv4&#x2F;route.c:2564</span><br><span class="line">   ip_route_output_key_hash+0x1ef&#x2F;0x360 net&#x2F;ipv4&#x2F;route.c:2393</span><br><span class="line">   __ip_route_output_key include&#x2F;net&#x2F;route.h:125 [inline]</span><br><span class="line">   ip_route_output_flow+0x28&#x2F;0xc0 net&#x2F;ipv4&#x2F;route.c:2651</span><br><span class="line">   ip_route_output_key include&#x2F;net&#x2F;route.h:135 [inline]</span><br><span class="line">   sctp_v4_get_dst+0x467&#x2F;0x1260 net&#x2F;sctp&#x2F;protocol.c:435</span><br><span class="line">   sctp_transport_route+0x12d&#x2F;0x360 net&#x2F;sctp&#x2F;transport.c:297</span><br><span class="line">   sctp_assoc_add_peer+0x53e&#x2F;0xfc0 net&#x2F;sctp&#x2F;associola.c:663</span><br><span class="line">   sctp_process_param net&#x2F;sctp&#x2F;sm_make_chunk.c:2531 [inline]</span><br><span class="line">   sctp_process_init+0x2491&#x2F;0x2b10 net&#x2F;sctp&#x2F;sm_make_chunk.c:2344</span><br><span class="line">   sctp_cmd_process_init net&#x2F;sctp&#x2F;sm_sideeffect.c:667 [inline]</span><br><span class="line">   sctp_cmd_interpreter net&#x2F;sctp&#x2F;sm_sideeffect.c:1369 [inline]</span><br><span class="line">   sctp_side_effects net&#x2F;sctp&#x2F;sm_sideeffect.c:1179 [inline]</span><br><span class="line">   sctp_do_sm+0x3a30&#x2F;0x50e0 net&#x2F;sctp&#x2F;sm_sideeffect.c:1150</span><br><span class="line">   sctp_assoc_bh_rcv+0x343&#x2F;0x660 net&#x2F;sctp&#x2F;associola.c:1059</span><br><span class="line">   sctp_inq_push+0x1e4&#x2F;0x280 net&#x2F;sctp&#x2F;inqueue.c:80</span><br><span class="line">   sctp_backlog_rcv+0x196&#x2F;0xbe0 net&#x2F;sctp&#x2F;input.c:339</span><br><span class="line">   sk_backlog_rcv include&#x2F;net&#x2F;sock.h:945 [inline]</span><br><span class="line">   __release_sock+0x129&#x2F;0x390 net&#x2F;core&#x2F;sock.c:2412</span><br><span class="line">   release_sock+0x59&#x2F;0x1c0 net&#x2F;core&#x2F;sock.c:2928</span><br><span class="line">   sctp_wait_for_connect+0x316&#x2F;0x540 net&#x2F;sctp&#x2F;socket.c:9039</span><br><span class="line">   __sctp_connect+0xab2&#x2F;0xcd0 net&#x2F;sctp&#x2F;socket.c:1226</span><br><span class="line">   __sctp_setsockopt_connectx+0x133&#x2F;0x1a0 net&#x2F;sctp&#x2F;socket.c:1334</span><br><span class="line">   sctp_setsockopt_connectx_old net&#x2F;sctp&#x2F;socket.c:1350 [inline]</span><br><span class="line">   sctp_setsockopt net&#x2F;sctp&#x2F;socket.c:4644 [inline]</span><br><span class="line">   sctp_setsockopt+0x22c0&#x2F;0x6d10 net&#x2F;sctp&#x2F;socket.c:4608</span><br><span class="line">   compat_sock_common_setsockopt+0x106&#x2F;0x140 net&#x2F;core&#x2F;sock.c:3137</span><br><span class="line">   __compat_sys_setsockopt+0x185&#x2F;0x380 net&#x2F;compat.c:383</span><br><span class="line">   __do_compat_sys_setsockopt net&#x2F;compat.c:396 [inline]</span><br><span class="line">   __se_compat_sys_setsockopt net&#x2F;compat.c:393 [inline]</span><br><span class="line">   __ia32_compat_sys_setsockopt+0xbd&#x2F;0x150 net&#x2F;compat.c:393</span><br><span class="line">   do_syscall_32_irqs_on arch&#x2F;x86&#x2F;entry&#x2F;common.c:337 [inline]</span><br><span class="line">   do_fast_syscall_32+0x27b&#x2F;0xd7d arch&#x2F;x86&#x2F;entry&#x2F;common.c:408</span><br><span class="line">   entry_SYSENTER_compat+0x70&#x2F;0x7f arch&#x2F;x86&#x2F;entry&#x2F;entry_64_compat.S:139</span><br><span class="line"> RIP: 0023:0xf7ff5849</span><br><span class="line"> Code: 85 d2 74 02 89 0a 5b 5d c3 8b 04 24 c3 8b 14 24 c3 8b 3c 24 c3 90 90</span><br><span class="line"> 90 90 90 90 90 90 90 90 90 90 51 52 55 89 e5 0f 34 cd 80 &lt;5d&gt; 5a 59 c3 90</span><br><span class="line"> 90 90 90 eb 0d 90 90 90 90 90 90 90 90 90 90 90 90</span><br><span class="line"> RSP: 002b:00000000f5df10cc EFLAGS: 00000296 ORIG_RAX: 000000000000016e</span><br><span class="line"> RAX: ffffffffffffffda RBX: 0000000000000007 RCX: 0000000000000084</span><br><span class="line"> RDX: 000000000000006b RSI: 000000002055bfe4 RDI: 000000000000001c</span><br><span class="line"> RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000</span><br><span class="line"> R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000</span><br><span class="line"> R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000</span><br><span class="line"> Allocated by task 480:</span><br><span class="line">   save_stack+0x23&#x2F;0x90 mm&#x2F;kasan&#x2F;common.c:71</span><br><span class="line">   set_track mm&#x2F;kasan&#x2F;common.c:79 [inline]</span><br><span class="line">   __kasan_kmalloc mm&#x2F;kasan&#x2F;common.c:489 [inline]</span><br><span class="line">   __kasan_kmalloc.constprop.0+0xcf&#x2F;0xe0 mm&#x2F;kasan&#x2F;common.c:462</span><br><span class="line">   kasan_slab_alloc+0xf&#x2F;0x20 mm&#x2F;kasan&#x2F;common.c:497</span><br><span class="line">   slab_post_alloc_hook mm&#x2F;slab.h:437 [inline]</span><br><span class="line">   slab_alloc mm&#x2F;slab.c:3326 [inline]</span><br><span class="line">   kmem_cache_alloc+0x11a&#x2F;0x6f0 mm&#x2F;slab.c:3488</span><br><span class="line">   dst_alloc+0x10e&#x2F;0x200 net&#x2F;core&#x2F;dst.c:93</span><br><span class="line">   rt_dst_alloc+0x83&#x2F;0x3f0 net&#x2F;ipv4&#x2F;route.c:1624</span><br><span class="line">   __mkroute_output net&#x2F;ipv4&#x2F;route.c:2337 [inline]</span><br><span class="line">   ip_route_output_key_hash_rcu+0x8f3&#x2F;0x2d50 net&#x2F;ipv4&#x2F;route.c:2564</span><br><span class="line">   ip_route_output_key_hash+0x1ef&#x2F;0x360 net&#x2F;ipv4&#x2F;route.c:2393</span><br><span class="line">   __ip_route_output_key include&#x2F;net&#x2F;route.h:125 [inline]</span><br><span class="line">   ip_route_output_flow+0x28&#x2F;0xc0 net&#x2F;ipv4&#x2F;route.c:2651</span><br><span class="line">   ip_route_output_key include&#x2F;net&#x2F;route.h:135 [inline]</span><br><span class="line">   sctp_v4_get_dst+0x467&#x2F;0x1260 net&#x2F;sctp&#x2F;protocol.c:435</span><br><span class="line">   sctp_transport_route+0x12d&#x2F;0x360 net&#x2F;sctp&#x2F;transport.c:297</span><br><span class="line">   sctp_assoc_add_peer+0x53e&#x2F;0xfc0 net&#x2F;sctp&#x2F;associola.c:663</span><br><span class="line">   sctp_process_param net&#x2F;sctp&#x2F;sm_make_chunk.c:2531 [inline]</span><br><span class="line">   sctp_process_init+0x2491&#x2F;0x2b10 net&#x2F;sctp&#x2F;sm_make_chunk.c:2344</span><br><span class="line">   sctp_sf_do_unexpected_init net&#x2F;sctp&#x2F;sm_statefuns.c:1541 [inline]</span><br><span class="line">   sctp_sf_do_unexpected_init.isra.0+0x7cd&#x2F;0x1350 net&#x2F;sctp&#x2F;sm_statefuns.c:1441</span><br><span class="line">   sctp_sf_do_5_2_1_siminit+0x35&#x2F;0x40 net&#x2F;sctp&#x2F;sm_statefuns.c:1670</span><br><span class="line">   sctp_do_sm+0x121&#x2F;0x50e0 net&#x2F;sctp&#x2F;sm_sideeffect.c:1147</span><br><span class="line">   sctp_assoc_bh_rcv+0x343&#x2F;0x660 net&#x2F;sctp&#x2F;associola.c:1059</span><br><span class="line">   sctp_inq_push+0x1e4&#x2F;0x280 net&#x2F;sctp&#x2F;inqueue.c:80</span><br><span class="line">   sctp_backlog_rcv+0x196&#x2F;0xbe0 net&#x2F;sctp&#x2F;input.c:339</span><br><span class="line">   sk_backlog_rcv include&#x2F;net&#x2F;sock.h:945 [inline]</span><br><span class="line">   __release_sock+0x129&#x2F;0x390 net&#x2F;core&#x2F;sock.c:2412</span><br><span class="line">   release_sock+0x59&#x2F;0x1c0 net&#x2F;core&#x2F;sock.c:2928</span><br><span class="line">   sctp_wait_for_connect+0x316&#x2F;0x540 net&#x2F;sctp&#x2F;socket.c:9039</span><br><span class="line">   __sctp_connect+0xab2&#x2F;0xcd0 net&#x2F;sctp&#x2F;socket.c:1226</span><br><span class="line">   sctp_connect net&#x2F;sctp&#x2F;socket.c:4846 [inline]</span><br><span class="line">   sctp_inet_connect+0x29c&#x2F;0x340 net&#x2F;sctp&#x2F;socket.c:4862</span><br><span class="line">   __sys_connect+0x264&#x2F;0x330 net&#x2F;socket.c:1834</span><br><span class="line">   __do_sys_connect net&#x2F;socket.c:1845 [inline]</span><br><span class="line">   __se_sys_connect net&#x2F;socket.c:1842 [inline]</span><br><span class="line">   __ia32_sys_connect+0x72&#x2F;0xb0 net&#x2F;socket.c:1842</span><br><span class="line">   do_syscall_32_irqs_on arch&#x2F;x86&#x2F;entry&#x2F;common.c:337 [inline]</span><br><span class="line">   do_fast_syscall_32+0x27b&#x2F;0xd7d arch&#x2F;x86&#x2F;entry&#x2F;common.c:408</span><br><span class="line">   entry_SYSENTER_compat+0x70&#x2F;0x7f arch&#x2F;x86&#x2F;entry&#x2F;entry_64_compat.S:139</span><br><span class="line"> Freed by task 9:</span><br><span class="line">   save_stack+0x23&#x2F;0x90 mm&#x2F;kasan&#x2F;common.c:71</span><br><span class="line">   set_track mm&#x2F;kasan&#x2F;common.c:79 [inline]</span><br><span class="line">   __kasan_slab_free+0x102&#x2F;0x150 mm&#x2F;kasan&#x2F;common.c:451</span><br><span class="line">   kasan_slab_free+0xe&#x2F;0x10 mm&#x2F;kasan&#x2F;common.c:459</span><br><span class="line">   __cache_free mm&#x2F;slab.c:3432 [inline]</span><br><span class="line">   kmem_cache_free+0x86&#x2F;0x260 mm&#x2F;slab.c:3698</span><br><span class="line">   dst_destroy+0x29e&#x2F;0x3c0 net&#x2F;core&#x2F;dst.c:129</span><br><span class="line">   dst_destroy_rcu+0x16&#x2F;0x19 net&#x2F;core&#x2F;dst.c:142</span><br><span class="line">   __rcu_reclaim kernel&#x2F;rcu&#x2F;rcu.h:222 [inline]</span><br><span class="line">   rcu_do_batch kernel&#x2F;rcu&#x2F;tree.c:2092 [inline]</span><br><span class="line">   invoke_rcu_callbacks kernel&#x2F;rcu&#x2F;tree.c:2310 [inline]</span><br><span class="line">   rcu_core+0xba5&#x2F;0x1500 kernel&#x2F;rcu&#x2F;tree.c:2291</span><br><span class="line">   __do_softirq+0x25c&#x2F;0x94c kernel&#x2F;softirq.c:293</span><br><span class="line"> The buggy address belongs to the object at ffff8880654f3a00</span><br><span class="line">   which belongs to the cache ip_dst_cache of size 176 The buggy address is located 23 bytes to the right of</span><br><span class="line">   176-byte region [ffff8880654f3a00, ffff8880654f3ab0) The buggy address belongs to the page:</span><br><span class="line"> page:ffffea0001953cc0 refcount:1 mapcount:0 mapping:ffff8880a76ad600</span><br><span class="line"> index:0xffff8880654f3c00</span><br><span class="line"> flags: 0x1fffc0000000200(slab)</span><br><span class="line"> raw: 01fffc0000000200 ffffea00026be808 ffffea000181c088 ffff8880a76ad600</span><br><span class="line"> raw: ffff8880654f3c00 ffff8880654f3000 0000000100000002 0000000000000000 page dumped because: kasan: bad access detected</span><br><span class="line"> Memory state around the buggy address:</span><br><span class="line">   ffff8880654f3980: fb fb fb fb fb fb fc fc fc fc fc fc fc fc fc fc</span><br><span class="line">   ffff8880654f3a00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">   ffff8880654f3a80: 00 00 00 00 00 00 fc fc fc fc fc fc fc fc fc fc</span><br><span class="line">                                               ^</span><br><span class="line">     ffff8880654f3b00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb</span><br><span class="line">     ffff8880654f3b80: fb fb fb fb fb fb fc fc fc fc fc fc fc fc fc fc &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; </span><br><span class="line"> </span><br><span class="line"> This bug is generated by a bot. It may contain errors.</span><br><span class="line"> See https:&#x2F;&#x2F;goo.gl&#x2F;tpsmEJ for more information about syzbot.</span><br><span class="line"> syzbot engineers can be reached at syzkaller@googlegroups.com.</span><br><span class="line"> syzbot will keep track of this bug report. See:</span><br><span class="line"> https:&#x2F;&#x2F;goo.gl&#x2F;tpsmEJ#status for how to communicate with syzbot.</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>从上面的信息可以看出在rt_cache_valid中访问了已经释放的dst。rt_cache_valid函数在rcu读临界区内，<br>先检查下是否是rcu锁问题。rcu锁的作用是防止dst在有读者的时候被释放，而出问题代码本身位于读临界区，<br>此时dst的回收代码不会执行到。dst是正常引用计数到达0时被rcu softirq reclaim掉的。dst引用统计被put了<br>多次导致计数为0 被释放了。跟踪下sctp下dst的释放流程，sctp_transport_route先release dst再执行get_dst。<br>由于release dst不在rcu的读临界区，在dst引用计数为0导致dst被回收后，在执行get_dst流程时引用的dst早已<br>被rcu sofirq释放。最简单的修复把release dst也放到rcu读临界区，这样在release dst和get dst的时候不<br>会触发rcu softirq的reclaim动作。</p>
]]></content>
      <categories>
        <category>network</category>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>sctp</tag>
      </tags>
  </entry>
  <entry>
    <title>从内核代码看openwrt的macvlan多拨</title>
    <url>/2019/05/13/%E4%BB%8E%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E7%9C%8Bopenwrt%E7%9A%84macvlan%E5%A4%9A%E6%8B%A8/</url>
    <content><![CDATA[<p>OpenWrt是一个嵌入式的 Linux 发行版， 拥有强大的网络组件和扩展性，<br>常常被用于工控设备、电话、小型机器人、智能家居、路由器以及VOIP设备中。</p>
<p>很多采用openwrt的软路由的人更多的是使用openwrt的多拨实现带宽叠加。<br>其实openwrt多拨是基于内核的macvlan模块。</p>
<h2 id="macvlan是什么？"><a href="#macvlan是什么？" class="headerlink" title="macvlan是什么？"></a>macvlan是什么？</h2><p>在macvlan之前，我们只能为一个物理网络接口添加多个ip地址，却不能添<br>加多个mac地址。macvlan可以在一个物理网络接口上虚拟出多个虚拟网络<br>接口，每个虚拟接口可以独立配置mac和ip地址。这样物理网络接口相当于<br>实现了一个交换机，记录了mac和虚拟接口的对应关系。</p>
<h3 id="macvlan收包处理流程"><a href="#macvlan收包处理流程" class="headerlink" title="macvlan收包处理流程"></a>macvlan收包处理流程</h3><p><img src="/2019/05/13/%E4%BB%8E%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E7%9C%8Bopenwrt%E7%9A%84macvlan%E5%A4%9A%E6%8B%A8/macvlan-1.png" alt="macvlan收包"></p>
<p>上图为内核的收包处理流程。内核为设置了macvlan的物理网络接口设置rx_handler函数，<br>在使用NAPI机制收到报文上送协议栈之前先执行macvlan_handle_frame。</p>
<p>macvlan_handle_frame函数根据二层头的目的mac地址判断是发给物理网络接口还是先发<br>给虚拟网络接口。设置skb-&gt;dev为macvlan设备，然后报文进入ip协议栈处理流程。</p>
<h3 id="maclavn发包流程"><a href="#maclavn发包流程" class="headerlink" title="maclavn发包流程"></a>maclavn发包流程</h3><p><img src="/2019/05/13/%E4%BB%8E%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E7%9C%8Bopenwrt%E7%9A%84macvlan%E5%A4%9A%E6%8B%A8/macvlan-2.png" alt="macvlan发包"></p>
<p>macvlan_queue_xmit是macvlan设备的发包函数，判断如果是桥模式则根据目的mac查找是否<br>是本机macvlan设备，如果是则直接发给本机macvlan设备执行netif_rx_internal。否则报文<br>通过底层设备发送出去。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有个macvlan，我们就可以基于虚拟网络接口进行pppoe拨号，从而获取多个wan连接，实现多拨。</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ol>
<li><a href="https://sreeninet.wordpress.com/2016/05/29/macvlan-and-ipvlan/" target="_blank" rel="noopener">macvlan and ipvlan</a></li>
<li><a href="http://hicu.be/bridge-vs-macvlan" target="_blank" rel="noopener">bridge vs macvlan</a></li>
</ol>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>macvlan</tag>
      </tags>
  </entry>
</search>
